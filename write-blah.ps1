param (
    [string]$OutputFile = "resumaker-source-code.md"
)

Clear-Host
Write-Host "Gathering Resume Maker source code files..." -ForegroundColor Yellow

# Define source directories and file extensions
$SourceDirs = @(
    "src",
    "lib"
)
$FileExtensions = @("*.tsx", "*.ts", "*.js", "*.jsx", "*.css", "*.mjs", "*.json", "*.md", "*.txt", "*.ps1", "*.yml", "*.yaml", "*.config", "*.env*")

# Define specific root files to include - EXPANDED LIST
$RootFiles = @(
    "package.json",
    "package-lock.json",
    "next.config.ts",
    "next.config.js",
    "tsconfig.json",
    "tailwind.config.ts",
    "tailwind.config.js",
    "postcss.config.mjs",
    "README.md",
    "PRD.md",
    "MVP.md",
    "scala.readme.md",
    "resume.md",
    "kaden-scala-data.json",
    "cala_resumemaker submodule to fix build",
    "write-blah.ps1",
    "next-env.d.ts",
    ".gitignore"
)

# Dynamic File Discovery
$FilesToInclude = @()
$FilesToInclude += $RootFiles | ForEach-Object { Get-Item -Path $_ -ErrorAction SilentlyContinue }
foreach ($dir in $SourceDirs) {
    if (Test-Path $dir) {
        $FilesToInclude += Get-ChildItem -Path $dir -Recurse -Include $FileExtensions -ErrorAction SilentlyContinue
    }
}

# Also scan for any additional files in root that might be relevant
$AdditionalRootFiles = Get-ChildItem -Path "." -File -Include "*.md", "*.json", "*.ts", "*.js", "*.ps1", "*.txt", "*.config*" | Where-Object { 
    $_.Name -notin $RootFiles -and 
    $_.Name -notlike "*.lock" -and 
    $_.Name -notlike "node_modules*" -and
    $_.Name -notlike ".git*" -and
    $_.Name -notlike ".next*" -and
    $_.Name -notlike "out*"
}
$FilesToInclude += $AdditionalRootFiles

$MarkdownContent = "# üîç Resume Maker Source Code Dump`n`n"
$MarkdownContent += "Generated: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')`n`n"
$MarkdownContent += "## Project: Next.js Resume Generator with PDF Export`n`n"

foreach ($file in $FilesToInclude) {
    if ($file -and (Test-Path $file.FullName)) {
        $RelativeFilePath = $file.FullName.Substring($PSScriptRoot.Length + 1)
        
        # Skip binary files and non-text files
        $FileExtension = $file.Extension.TrimStart('.').ToLower()
        if ($FileExtension -in @('png', 'jpg', 'jpeg', 'gif', 'svg', 'ico', 'woff', 'woff2', 'ttf', 'eot', 'pdf', 'zip', 'exe', 'dll', 'so', 'dylib')) {
            continue
        }
        
        $MarkdownContent += "`n## File: $RelativeFilePath`n`n"

        try {
            Write-Host "Processing: $RelativeFilePath" -ForegroundColor Green
            
            $FileContent = Get-Content -Path $file.FullName -Raw -ErrorAction Stop

            if ([string]::IsNullOrWhiteSpace($FileContent)) {
                $MarkdownContent += "*File is empty*`n"
                continue
            }

            # Check if content looks like text (not binary)
            if ($FileContent -match '[^\x00-\x08\x0B\x0C\x0E-\x1F\x7F]') {
                $LanguageSyntax = switch ($FileExtension) {
                    { $_ -in @('ts', 'tsx') } { 'typescript' }
                    'js'   { 'javascript' }
                    'mjs'  { 'javascript' }
                    'json' { 'json' }
                    'md'   { 'markdown' }
                    'css'  { 'css' }
                    'ps1'  { 'powershell' }
                    'yml'  { 'yaml' }
                    'yaml' { 'yaml' }
                    default { '' }
                }

                $MarkdownContent += "``````$LanguageSyntax`n"
                $MarkdownContent += $FileContent
                $MarkdownContent += "`n``````n`n"
            } else {
                $MarkdownContent += "*Binary file - skipped*`n`n"
            }
        }
        catch {
            Write-Warning "Could not read file: '$RelativeFilePath'. Error: $($_.Exception.Message)"
            $MarkdownContent += "*Could not read file: $($_.Exception.Message)*`n`n"
        }
    }
}

# Add footer
$MarkdownContent += "`n---`n"
$MarkdownContent += "*Generated by Write-blah.ps1 for Resume Maker (Next.js + @react-pdf/renderer)*`n"

try {
    $MarkdownContent | Out-File -FilePath $OutputFile -Encoding UTF8 -Force
    Write-Host "`n‚úÖ Success! Source code written to '$OutputFile'" -ForegroundColor Green
    Write-Host "üì¶ File size: $((Get-Item $OutputFile).Length) bytes" -ForegroundColor Cyan
    Write-Host "`nüìã Ready to share with LLM for debugging PDF export issues" -ForegroundColor Yellow
}
catch {
    Write-Error "‚ùå Failed to write output file '$OutputFile': $($_.Exception.Message)"
    exit 1
}
